{"remainingRequest":"C:\\Users\\EDZ\\Desktop\\研发项目\\vue-project\\trunk\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\EDZ\\Desktop\\研发项目\\vue-project\\trunk\\src\\utils\\clone.js","dependencies":[{"path":"C:\\Users\\EDZ\\Desktop\\研发项目\\vue-project\\trunk\\src\\utils\\clone.js","mtime":1572415126495},{"path":"C:\\Users\\EDZ\\Desktop\\研发项目\\vue-project\\trunk\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1558492728398},{"path":"C:\\Users\\EDZ\\Desktop\\研发项目\\vue-project\\trunk\\node_modules\\babel-loader\\lib\\index.js","mtime":1558492720858}],"contextDependencies":[],"result":["import \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _typeof from \"C:\\\\Users\\\\EDZ\\\\Desktop\\\\\\u7814\\u53D1\\u9879\\u76EE\\\\vue-project\\\\trunk\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/typeof\";\n\n/**\r\n * Get the first item that pass the test\r\n * by second argument function\r\n *\r\n * @param {Array} list\r\n * @param {Function} f\r\n * @return {*}\r\n */\nfunction find(list, f) {\n  return list.filter(f)[0];\n}\n/**\r\n * Deep copy the given object considering circular structure.\r\n * This function caches all nested objects and its copies.\r\n * If it detects circular structure, use cached copy to avoid infinite loop.\r\n *\r\n * @param {*} obj\r\n * @param {Array<Object>} cache\r\n * @return {*}\r\n */\n\n\nexport function deepCopy(obj, cache) {\n  if (cache === void 0) cache = []; // just return if obj is immutable value\n\n  if (obj === null || _typeof(obj) !== 'object') {\n    return obj;\n  } // if obj is hit, it is in circular structure\n\n\n  var hit = find(cache, function (c) {\n    return c.original === obj;\n  });\n\n  if (hit) {\n    return hit.copy;\n  }\n\n  var copy = Array.isArray(obj) ? [] : {}; // put the copy into cache at first\n  // because we want to refer it in recursive deepCopy\n\n  cache.push({\n    original: obj,\n    copy: copy\n  });\n  Object.keys(obj).forEach(function (key) {\n    copy[key] = deepCopy(obj[key], cache);\n  });\n  return copy;\n}",{"version":3,"sources":["C:\\Users\\EDZ\\Desktop\\研发项目\\vue-project\\trunk\\src\\utils\\clone.js"],"names":["find","list","f","filter","deepCopy","obj","cache","hit","c","original","copy","Array","isArray","push","Object","keys","forEach","key"],"mappings":";;;;AAAA;;;;;;;;AAQA,SAASA,IAAT,CAAcC,IAAd,EAAoBC,CAApB,EAAuB;AACnB,SAAOD,IAAI,CAACE,MAAL,CAAYD,CAAZ,EAAe,CAAf,CAAP;AACH;AAED;;;;;;;;;;;AASA,OAAO,SAASE,QAAT,CAAkBC,GAAlB,EAAuBC,KAAvB,EAA8B;AACjC,MAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsBA,KAAK,GAAG,EAAR,CADW,CAGjC;;AACA,MAAID,GAAG,KAAK,IAAR,IAAgB,QAAOA,GAAP,MAAe,QAAnC,EAA6C;AACzC,WAAOA,GAAP;AACH,GANgC,CAQjC;;;AACA,MAAIE,GAAG,GAAGP,IAAI,CAACM,KAAD,EAAQ,UAAUE,CAAV,EAAa;AAAE,WAAOA,CAAC,CAACC,QAAF,KAAeJ,GAAtB;AAA4B,GAAnD,CAAd;;AACA,MAAIE,GAAJ,EAAS;AACL,WAAOA,GAAG,CAACG,IAAX;AACH;;AAED,MAAIA,IAAI,GAAGC,KAAK,CAACC,OAAN,CAAcP,GAAd,IAAqB,EAArB,GAA0B,EAArC,CAdiC,CAejC;AACA;;AACAC,EAAAA,KAAK,CAACO,IAAN,CAAW;AACPJ,IAAAA,QAAQ,EAAEJ,GADH;AAEPK,IAAAA,IAAI,EAAEA;AAFC,GAAX;AAKAI,EAAAA,MAAM,CAACC,IAAP,CAAYV,GAAZ,EAAiBW,OAAjB,CAAyB,UAAUC,GAAV,EAAe;AACpCP,IAAAA,IAAI,CAACO,GAAD,CAAJ,GAAYb,QAAQ,CAACC,GAAG,CAACY,GAAD,CAAJ,EAAWX,KAAX,CAApB;AACH,GAFD;AAIA,SAAOI,IAAP;AACH","sourcesContent":["/**\r\n * Get the first item that pass the test\r\n * by second argument function\r\n *\r\n * @param {Array} list\r\n * @param {Function} f\r\n * @return {*}\r\n */\r\nfunction find(list, f) {\r\n    return list.filter(f)[0]\r\n}\r\n\r\n/**\r\n * Deep copy the given object considering circular structure.\r\n * This function caches all nested objects and its copies.\r\n * If it detects circular structure, use cached copy to avoid infinite loop.\r\n *\r\n * @param {*} obj\r\n * @param {Array<Object>} cache\r\n * @return {*}\r\n */\r\nexport function deepCopy(obj, cache) {\r\n    if (cache === void 0) cache = [];\r\n\r\n    // just return if obj is immutable value\r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj\r\n    }\r\n\r\n    // if obj is hit, it is in circular structure\r\n    var hit = find(cache, function (c) { return c.original === obj; });\r\n    if (hit) {\r\n        return hit.copy\r\n    }\r\n\r\n    var copy = Array.isArray(obj) ? [] : {};\r\n    // put the copy into cache at first\r\n    // because we want to refer it in recursive deepCopy\r\n    cache.push({\r\n        original: obj,\r\n        copy: copy\r\n    });\r\n\r\n    Object.keys(obj).forEach(function (key) {\r\n        copy[key] = deepCopy(obj[key], cache);\r\n    });\r\n\r\n    return copy\r\n}"]}]}